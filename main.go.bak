package main

import (
	"fmt"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
	"github.com/bitly/go-simplejson"
	"os"
	"os/signal"
	"syscall"
	"time"
)

type Asserts struct {
	regular		int64 "regular"
	warning		int64 "warning"
	msg		int64 "msg"
	user		int64 "user"
	rollovers       int64 "rollovers"
}

type Connections struct {
	Current      int64 "current"
	Available    int64 "available"
	TotalCreated int64 "totalCreated"
}

type ExtraInfo struct {
	pageFaults       int64 "page_faults"
	heapUsageInBytes int64 "heap_usage_bytes"
}

type Mem struct {
	resident          int64 "resident"
	virtual           int64 "virtual"
	mapped            int64 "mapped"
	mappedWithJournal int64 "mappedWithJournal"
}

type GL struct {
	readers int64 "readers"
	writers int64 "writers"
	total   int64 "total"
}

type GlobalLock struct {
	totalTime     int64 "totalTime"
	lockTime      int64 "lockTime"
	currentQueue  GL   "currentQueue"
	activeClients GL   "activeClients"
}

type Opcounters struct {
	insert  int64 "insert"
	query   int64 "query"
	update  int64 "update"
	delete  int64 "delete"
	getMore int64 "getmore"
	command int64 "command"
}

type WiredTigerCache struct {
	bytesCurrent	int64	"bytes currently in the cache"
	pagesCurrent	int64	"pages currently held in the cache"
	bytesRead	int64	"bytes read into cache"
	pagesRead	int64	"pages read into cache"
	bytesWritten	int64	"bytes written from cache"
        pagesWritten	int64	"pages written from cache"
	bytesDirety	int64	"tracked dirty bytes in the cache"
        pagesDirety	int64	"tracked dirty pages in the cache"
	pagesModifiedEvicted	int64	"modified pages evicted"
	pagesUnModifiedEvicted	int64	"unmodified pages evicted"
}

type WiredTigerLog struct {
	logBytesWritten		int64 "log bytes written"
	logWriteOperations	int64 "log write operations"
	totalLogBuffer		int64 "total log buffer size"
}

type WiredTigerTransaction struct {
	committed	int64 "transactions committed"
	rolledBack	int64 "transactions rolled back"
}

type WTCT struct {
	out		int64 "out"
	available	int64 "available"
	totalTickets	int64 "totalTickets"
}

type WiredTigerConcurrentTransaction struct {
	write WTCT "write"
	read WTCT "read"
}

type WiredTiger struct {
	cache			WiredTigerCache		"cache"
	log			WiredTigerLog		"log"
	transaction		WiredTigerTransaction	"transaction"
	concurrentTransactions	WiredTigerConcurrentTransaction	"concurrentTransactions"
}

type ServerStatus struct {
	host                 string              "host"
	version              string              "version"
	process              string              "process"
	pid                  int64               "pid"
	uptime               int64               "uptime"
	uptimeInMillis       int64               "uptimeMillis"
	uptimeEstimate       int64               "uptimeEstimate"
	localTime            bson.MongoTimestamp "localTime"
	connections          Connections         "connections"
	extraInfo            ExtraInfo           "extra_info"
	mem                  Mem                 "mem"
	globalLocks          GlobalLock          "globalLock"
	opcounters           Opcounters          "opcounters"
        wriredTiger	     WiredTiger          "wiredTiger"
	opcountersReplicaSet Opcounters          "opcountersRepl"
}

func serverStatus(mongo_config Mongo) ServerStatus {
	info := mgo.DialInfo{
		Addrs:   mongo_config.Addresses,
		Direct:  false,
		Timeout: time.Second * 30,
	}

	session, err := mgo.DialWithInfo(&info)
	if err != nil {
		panic(err)
	}
	defer session.Close()

	if len(mongo_config.User) > 0 {
		cred := mgo.Credential{Username: mongo_config.User, Password: mongo_config.Pass}
		err = session.Login(&cred)
		if err != nil {
			panic(err)
		}
	}

	// Optional. Switch the session to a monotonic behavior.
	session.SetMode(mgo.Monotonic, true)

	var s ServerStatus
        
        var result = &bson.M{}
	if err := session.Run("serverStatus", result); err != nil {
		panic(err)
	}

        resultJs, err := bson.MarshalJSON(result)
        if err != nil {
		panic(err)
        }

        fmt.Println("ok")
        fmt.Println(resultJs)

        js, err := simplejson.NewJson(resultJs)
        if err != nil {
		panic(err)
	}

        fmt.Println(js.Get("version"))

	return s
}

func main() {
	config := LoadConfig()

	ticker := time.NewTicker(config.Interval)
	quit := make(chan struct{})

        fmt.Println(serverStatus(config.Mongo))

	go func() {
		for {
			select {
			case <-ticker.C:
                                fmt.Println("-----------------")
                                fmt.Println(time.Now().String())
                                fmt.Println("---")
                                status := serverStatus(config.Mongo)

                                connections := status.connections
                                fmt.Println(fmt.Sprintf("Connections: current %d, available %d, totalCreated %d", connections.Current, connections.Available, connections.TotalCreated))

                                mem := status.mem
                                extra := status.extraInfo
                                fmt.Println(fmt.Sprintf("Mem: resident %d, virtual %d, pageFaults %d, heapUsageInBytes %d", mem.resident, mem.virtual, extra.pageFaults, extra.heapUsageInBytes))

                                globalLock := status.globalLocks
                                fmt.Println(fmt.Sprintf("GlobalLock: totalTime %d, locktime %d", globalLock.totalTime, globalLock.lockTime))
                                fmt.Println(fmt.Sprintf("    CurrentQueue: readers %d, writers %d, total: %d", globalLock.currentQueue.readers, globalLock.currentQueue.writers, globalLock.currentQueue.total))
                                fmt.Println(fmt.Sprintf("    ActiveClients: readers %d, writers %d, total: %d", globalLock.activeClients.readers, globalLock.activeClients.writers, globalLock.activeClients.total))

                                op := status.opcounters
                                fmt.Println(fmt.Sprintf("Op: insert %d, query %d, upate %d, delete %d, getMore %d, command %d", op.insert, op.query, op.update, op.delete, op.getMore, op.command))

                                concurrent := status.wriredTiger.concurrentTransactions
                                fmt.Println("Concurrent:")
                                fmt.Println(fmt.Sprintf("    write: out %d available %d totalTickets %d", concurrent.write.out, concurrent.write.available, concurrent.write.totalTickets))
                                fmt.Println(fmt.Sprintf("    read: out %d available %d totalTickets %d", concurrent.read.out, concurrent.read.available, concurrent.read.totalTickets))

			case <-quit:
				ticker.Stop()
				return
			}
		}
	}()
	ch := make(chan os.Signal)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
	sig := <-ch
	fmt.Println("Received " + sig.String())
	close(quit)
}
